# 流水线

1. Fetch(取指令):这部分负责从 I-Cache 中取指令，主要由两大部件构成， I-Cache 负责存储最近常用的指令;分支预测器用来决定下一条指令的 PC 值。不同于普通的处理器，这两大部件在超标量处理器中会遇到新的问题，都需要进行特殊的处理。
2. Decode(解码):这部分用来识别出指令的类型、指令需要的操作数以及指令的一些控制信号等，这部分的设计和指令集是息息相关的，对于 RISC 指令集来说，例如 MIPS，由于比较简洁，所以解码部分也就相对比较简单，而对于 CISC 指令集来说，例如 x86，由于比较复杂，所以解码部分需要更多的逻辑电路来对这些指令进行识别，但是在超标量处理器中，即使对于 RISC 指令集，仍旧需要对一些特殊的指令进行处理，这些内容增加了解码部分的设计复杂度。
3. Register Renaming(寄存器重命名):在流水线的解码阶段，可以得到指令的源寄存器和目的寄存器，这些寄存器都是逻辑寄存器，在指令集中定义好的，为了解决 WAW 和 WAR 这两种“伪相关性”，需要使用寄存器重命名的方法，将指令集中定义的逻辑寄存器重命名为处理器内部使用的物理寄存器，物理寄存器的个数要多于逻辑寄存器，通过寄存器重命名，处理器可以调度更多可以并行执行的指令。在进行重命名时，通常使用一个表格来存储当前逻辑寄存器到物理寄存器之间的对应关系，同时在其中还存储着哪些物理寄存器还没有被使用等信息，使用一些电路来分析当前周期被重命名的指令之间的RAW相关性，将那些存在RAW相关性的指令加以标记，这些指令会通过后续的旁路网络(bypassing network)来解决它们之间存在的“真相关性”。由于寄存器重命名阶段需要的时间比较长，现实当中的处理器都会将其单独使用一级流水线，而不是和解码阶段放在一起。
4. Dispatch(分发):在这个阶段，被重命名之后的指令会按照程序中规定的顺序，写到发射队列(IssueQueue)、重排序缓存(ROB)和 StoreBuffer 等部件中，如果在这些部件中没有空闲的空间可以容纳当前的指令，那么这些指令就需要在流水线的重命名阶段进行等待，这就相当于暂停了寄存器重命名以及之前的所有流水线，直到这些部件中有空闲的空间为止。分发阶段可以和寄存器重命名阶段放在一起，在一些对周期时间要求比较紧的处理器中，也可以将这个部分单独使用一个流水段。
5. Issue(发射):经过流水线的分发(Dispatch)阶段之后，指令被写到了发射队列(IssueQueue)中，仲裁(select)电路会从这个部件中挑选出合适的指令送到 FU 中执行，这个仲裁电路可繁可简，对于顺序进行发射(in-orderissue)的情况，只需要判断发射队列中最旧的那条指令是否准备好就可以了，而对于乱序进行发射(out-of-orderissue)的情况，则仲裁电路会变得比较复杂，它需要对发射队列中所有的指令进行判断，并从所有准备好的指令中找出最合适的那条指令，送到 FU 中执行，对于乱序执行的处理器，这个阶段是顺序执行(in-order)到乱序执行(out-of-order)的分界点，指令在这个阶段之后，都是按照乱序的方式来执行，直到流水线的提交(Commit)阶段，才会重新变为顺序执行的状态。在发射队列中还存在唤醒(wake-up)电路，它可以将发射队列中对应的源操作数置为有效的状态，仲裁电路和唤醒电路互相配合进行工作，是超标量处理器中的关键路径。
6. Register File Read(读取寄存器):被仲裁电路选中的指令需要从物理寄存器堆(Physical Register File，PRF)中读取操作数，一般情况下，被仲裁电路选中的指令可以从PRF中得到源操作数，当然还有“不一般”的情况，那就是指令不能从 PRF 中得到操作数，但是却可以在送到 FU 中执行之前，从旁路网络(bypassing network)中得到操作数，事实上很大一部分指令都是通过旁路网络获得操作数的[35]，这也为减少 PRF 的读端口提供了可能。由于超标量处理器每周期需要执行好几条指令，PRF 所需要的端口个数也是比较多的，多端口寄存器堆的访问速度一般都不会很快，因此在现实世界的处理器中，这个阶段都会单独使用一个流水段。
7. Execute(执行):指令得到了它所需要的操作数之后，马上就可以送到对应的 FU 中执行了，在超标量处理器中，这个阶段通常有很多个不同类型的 FU，例如负责普通运算的 FU、负责乘累加运算的 FU、负责分支指令运算的 FU、负责load/store指令执行的 FU 等，现代的处理器还会加入一些多媒体运算的 FU，例如进行单指令多数据(SIMD)运算的 FU。
8. Write back(写回):这个阶段会将 FU 计算的结果写到物理寄存器堆(PRF)中，同时这个阶段还有一个重要的功能，就是通过旁路网络(bypassing network)将这个计算结果送到需要的地方，一般都是送到所有 FU 的输入端，由 FU 输入端的控制电路来决定最终需要的数据，在现代的处理器中，旁路网络是影响速度的关键因素，因为这部分电路需要大量的布线，而随着硅工艺尺寸的减少，连线的延迟甚至超过了门电路的延迟，因此旁路网络会严重影响处理器的周期时间，为了解决这个问题，很多处理器都使用了 Cluster的结构，将 FU 分成不同的组，在一个组内的 FU，布局布线时会被紧挨在一起，这样在这个组内的旁路网络，由于经过的路径比较短，一般都可以在一个周期内完成;而当旁路网络跨越不同的组时，就需要两个甚至多个周期了，这种 Cluster 的结构是一种典型的折中方案。
9. Commit(提交):这个阶段起主要作用的部件是重排序缓存(ROB)，它会将乱序执行的指令拉回到程序中规定的顺序，之所以能够完成这样的任务，是因为指令在流水线的分发(Dispatch)阶段，按照程序中规定的顺序(in-order)写到了重排序缓存中;程序在处理器中表现出来的结果总是串行的，如果在程序中先向寄存器R1写数据，然后向寄存器R2写数据，那么处理器表现出来的执行结果一定是先写R1再写R2，也就是说，处理器执行的结果要和程序中原始的顺序是一样的，但是在超标量处理器中，指令是按照乱序的方式在内部执行的，最后需要这样一个阶段，将这些乱序执行的指令变回到程序规定的原始顺序;在重排序缓存中，如果一条指令之前的指令还没有执行完，那么即使这条指令已经执行完了，它也不能离开重排序缓存，必须等待它之前的所有指令都执行完成;在这个阶段也会对指令产生的异常(exception)进行处理，指令在流水线的很多阶段都可能发生异常，但是所有的异常都必须等到指令到达流水线的提交(Commit)阶段时才能进行处理，这样可以保证异常的处理按照程序中规定的顺序进行，并且能够实现精确的异常;一条指令一旦从重排序缓存中离开而退休(retire)，那么就对处理器的状态进行了修改，再也无法返回到之前的状态了。



